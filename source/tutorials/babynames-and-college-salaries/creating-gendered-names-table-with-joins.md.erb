---
title: Using SQL Joins to Analyze a Year's Worth of Gendered Baby Names 
description: |
  A walkthrough on how to create and fill new tables, and then a review of INNER and LEFT joins.
ranking: 1442
listed: true
next: /tutorials/babynames-and-college-salaries/florida-university-employees-and-gender/
previous: /tutorials/babynames-and-college-salaries/inner-left-joins-few-babynames/
---


Did you create the `boynames` and `girlnames` tables [as shown in the previous lesson](/tutorials/babynames-and-college-salaries/inner-left-joins-few-babynames/)? If not, no matter, just run the following code to DROP the tables (if they exist) and then recreate them:


~~~sql
DROP TABLE IF EXISTS boynames;
DROP TABLE IF EXISTS girlnames;
CREATE TABLE boynames(
  "name" VARCHAR,
  "babies" INTEGER
);
CREATE TABLE girlnames(
  "name" VARCHAR,
  "babies" INTEGER
);
~~~

Now let's populate those tables, starting with `boynames`. The query to SELECT all names given to boys from the `babynames` table is simply this (remember, we don't need to keep/display the `sex` column, as it's redundant):

~~~sql
SELECT name, babies 
FROM babynames
WHERE sex = 'M';
~~~

How do we get that into the `boynames` table? We could rely on the GUI: DB Browser for SQLite has an __Export__ button to save results as a CSV, which we could then re-import (again via the GUI) into `boynames`. 

But that's cumbersome compared to executing this in SQL -- basically, you're inserting into a table the results of the given query:

~~~sql
INSERT INTO boynames
  SELECT name, babies 
  FROM babynames
  WHERE sex = 'M';
~~~


In fact, it's easy enough to do everything in a series of queries, including re-creating the tables and inserting the `SELECT` query as data.

~~~sql
DROP TABLE IF EXISTS boynames;
DROP TABLE IF EXISTS girlnames;
CREATE TABLE boynames(
  "name" VARCHAR,
  "babies" INTEGER
);
CREATE TABLE girlnames(
  "name" VARCHAR,
  "babies" INTEGER
);
INSERT INTO boynames
  SELECT name, babies 
  FROM babynames
  WHERE sex = 'M';
INSERT INTO girlnames
  SELECT name, babies 
  FROM babynames
  WHERE sex = 'F';
~~~


Now we can re-do the queries from the last lesson, except with all the baby names.


## The number of names that were given to both boys and girls

Just in case we've forgotten this trivial number, let's count how many unique names are in `babynames`:

<%= content_row_side_by_side(%Q{

~~~sql
SELECT COUNT(DISTINCT name)
FROM babynames;
~~~
},%Q{

|----------------------|
| COUNT(DISTINCT name) |
|----------------------|
|                22674 |
|----------------------|
{:.table-sql}

}) %>


Now let's get a count of names that appear in both `girlnames` and `boynames` with an INNER JOIN (we don't need to use `DISTINCT` because, by definition, each resulting name will be distinct):

<%= content_row_side_by_side(%Q{

~~~sql
SELECT COUNT(*)
FROM girlnames
INNER JOIN boynames
  ON girlnames.name = boynames.name;
~~~
}, %Q{
|------------|
|  COUNT(*)  |
|------------|
|  2039      |
|------------|
{:.table-sql}

}) %>

A little less than 10% of the names are given to babies of both sex. Let's see which ones are the most popular among boys and girls, respectively:

<%= content_row_side_by_side(%Q{
~~~sql
SELECT girlnames.name,
  girlnames.babies AS girl_babies,
  boynames.babies AS boy_babies
FROM girlnames
INNER JOIN boynames ON
  girlnames.name = boynames.name
ORDER BY girl_babies DESC
LIMIT 5;
~~~
  
},%Q{

|-----------+-------------+-------------|
|  name     | girl_babies | boy_babies  |
|-----------+-------------+-------------|
|  Jessica  | 46466       | 140         |
|  Ashley   | 45549       | 239         |
|  Brittany | 36535       | 112         |
|  Amanda   | 34406       | 96          |
|  Samantha | 25864       | 58          |
|-----------+-------------+-------------|
{:.table-sql}

}) %>

To do the same for boys, we can use the same query, but change the `ORDER BY` clause to sort by `boy_babies`:

<%= content_row_side_by_side(%Q{
~~~sql
SELECT girlnames.name,
  girlnames.babies AS girl_babies,
  boynames.babies AS boy_babies
FROM girlnames
INNER JOIN boynames ON
  girlnames.name = boynames.name
ORDER BY boy_babies DESC
LIMIT 5;
~~~
},%Q{

|--------------+-------------+-------------|
|  name        | girl_babies | boy_babies  |
|--------------+-------------+-------------|
|  Michael     | 277         | 65274       |
|  Christopher | 188         | 52323       |
|  Matthew     | 125         | 44794       |
|  Joshua      | 166         | 43214       |
|  Daniel      | 148         | 33809       |
|--------------+-------------+-------------|
{:.table-sql}
  
}) %>


A quick sidenote: it seems a bit strange that, according to this 1990 data from the Social Security Administration, there are nearly 500 boys who were given the names of either Jessica, Ashley, or Brittany. I mean, according to the following query:

~~~sql
SELECT *
FROM babynames
WHERE name = 'Sue';
~~~

There are only __11__ boys named '__Sue__', despite there being a popular Shel Silverstein and famous Johnny Cash song about a boy named Sue. I know exploring data often challenges one's assumptions, but I kind of _feel_ that we would be hearing a lot more [This American Life](http://www.thisamericanlife.org/) episodes on the childhoods of boys named "Jessica" and girls named "Joshua"...But let's move on for now.


## Calculating the most androgynous names

In the previous queries, we found the most popular names that happened to also be given to babies of both sexes. But what about names that have the most purported gender ambivalence, i.e. names given to roughly the same number of boys as girls.

There's a few approaches to this:

### Calculating the absolute difference between number of boys and girls

If 100 boys and 100 girls were given a particular name, then the _difference_ between `boy_babies` and `girl_babies` would be small, i.e. 0. So one way to find most gender-flexible name is to subtract one from the other, and sort by the smallest _absolute number_ of the difference:


<%= content_row_side_by_side(%Q{
~~~sql
SELECT girlnames.name,
  ABS(girlnames.babies - boynames.babies) AS diff_count,
  girlnames.babies + boynames.babies AS total_count
FROM girlnames
INNER JOIN boynames ON
  girlnames.name = boynames.name
ORDER BY diff_count ASC
LIMIT 5;
~~~
},%Q{

|----------+------------+--------------|
|  name    | diff_count | total_count  |
|----------+------------+--------------|
|  Michal  | 0          | 138          |
|  Layne   | 0          | 136          |
|  Charley | 0          | 112          |
|  Adrean  | 0          | 32           |
|  Yee     | 0          | 32           |
|----------+------------+--------------|
{:.table-sql}
  
}) %>


This is only mildly interesting, as all of those names are pretty rare. Let's use a `WHERE` clause to only include names in which `total_count` is at least __1,000__:

<%= content_row_side_by_side(%Q{
~~~sql
SELECT girlnames.name,
  ABS(girlnames.babies - boynames.babies) AS diff_count,
  girlnames.babies + boynames.babies AS total_count
FROM girlnames
INNER JOIN boynames ON
  girlnames.name = boynames.name
WHERE total_count >= 1000
ORDER BY diff_count ASC
LIMIT 5;
~~~
},%Q{

|------------+------------+--------------|
|  name      | diff_count | total_count  |
|------------+------------+--------------|
|  Infant    | 16         | 1176         |
|  Jessie    | 139        | 2371         |
|  Ashton    | 195        | 1469         |
|  Kendall   | 224        | 1508         |
|  Dominique | 460        | 3430         |
|------------+------------+--------------|
{:.table-sql}
  
}) %>

Mmmkay...nearly 1,200 mothers named their baby, "Infant"? Either American parents are even stranger than we thought or we have more reason to think that the SSA data isn't 100% what we expect it to be...

<a id="mark-boygirls-total-babies"></a>

### Calculating the ratio of boys/girls versus total babies

Another way to do the calculation is to divide either `boy_babies` or `girl_babies` by `total_babies`, multiply by 100 (to get a round number), then sort by the absolute difference between the ratio and 50, as 50% is what the ratio would be if a name was split evenly between boys and girls.

This is not particularly different in strategy than the previous strategy using `ABS`. But note how the `ABS` function is used in the `ORDER BY` clause -- that's always an option.

Again, we use `WHERE` to limit it to names that have been given to more than 1,000 babies:

<%= content_row_side_by_side(%Q{
~~~sql
SELECT girlnames.name,
  girlnames.babies + boynames.babies AS total_count,
  girlnames.babies * 100.0 / 
        (girlnames.babies + boynames.babies) AS girl_ratio
FROM girlnames
INNER JOIN boynames ON
  girlnames.name = boynames.name
WHERE total_count >= 1000
ORDER BY ABS(50 - girl_ratio) ASC
LIMIT 5;
~~~
},%Q{

|---------+-------------+-------------------|
|  name   | total_count | girl_ratio        |
|---------+-------------+-------------------|
|  Infant | 1176        | 49.3197278911565  |
|  Taylor | 13830       | 52.4656543745481  |
|  Jessie | 2371        | 47.0687473639814  |
|  Casey  | 7391        | 44.1212285211744  |
|  Ashton | 1469        | 56.6371681415929  |
|---------+-------------+-------------------|
{:.table-sql}
  
}) %>

Slightly different results because of the way the math works out. But I bring up this convoluted approach because it's more helpful to calculate the boy/girl ratio of a name for our bigger purpose: creating a lookup table that makes it easy to determine if any given name is more popular among boys or girls.

Let's call this table (for lack of better name): `gendered_names`




# Designing the `gendered_names` table

Basically, I want `gendered_names` to be structured such that I can query for any single name and it returns:

1. The `gender` the name is most associated with, e.g. `M` or `F`
2. The `ratio` of babies, with the given `gender`, who were given that name.
3. The `total_babies` given that name. Because for very rare names, the statistical significance of `ratio` may not be very important.

And obviously, the `gendered_names` table would have to have a `name` column to query against. To keep things simple and consistent with the `florida_positions` table (remember that table), we'll also uppercase the names.

Here's a sample query and result:

~~~sql
SELECT * 
FROM gendered_names
WHERE name = 'DAKOTA';
~~~


## Creating the `gendered_names` table

You know how to create a table in SQL by now, try to think what the statement looks like before checking what I think it should be:

~~~sql
CREATE TABLE "gendered_names"(
  "name" VARCHAR,
  "gender" CHAR,
  "ratio" INTEGER,
  "total_babies" INTEGER
);
~~~

(Again, specifying `VARCHAR` and `CHAR` are totally optional for SQLite...you could just as well use `TEXT` -- I do it out of habit from using MySQL for so long...)

## Filling the `gendered_names` table

Obviously, we're going to re-use that `INSERT INTO` statement that we learned just in this lesson -- there's no point in further explaining it...it just works, when it comes to transferring data between exiting SQLite tables.

But what `SELECT` statement do we use? In my mind, it's simplest to do __two__ queries that calculate the gender ratio, [similar to what we just did](#mark-boygirls-total-babies) -- in other words, perform the `INSERT INTO` query separately for male- and female-dominated names.

### Filtering male- and female- dominated names 

How to divide the set of baby names between mostly-male and mostly-female? Easy, just use a `WHERE` clause: where `boy_babies` > `girl_babies`, it's a "mostly-male" name. And vice versa, for names where `girl_babies` is greater than or equal to `boy_babies`, designated it as "mostly-female" -- Let whomever is querying `gendered_names` decide what to do with names where the `ratio` is near 50.

So to fill `gendered_names`, we'll be executing two very similar-but-not-quite-identical queries. First, the boys; here's what the output of the query looks like before we `INSERT INTO` the `gendered_names` table.

First, the boys...but before we do the `INSERT INTO`, let's preview what this query does:


<%= content_row_side_by_side(%Q{
  

~~~sql
SELECT boynames.name,
  'M' AS gender,
  (100 * boynames.babies) /  (boynames.babies + girlnames.babies) AS ratio,
  boynames.babies + girlnames.babies AS total_babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;
~~~

},%Q{
  

|--------------+--------+-------+---------------|
|  name        | gender | ratio | total_babies  |
|--------------+--------+-------+---------------|
|  Michael     | M      | 99    | 65551         |
|  Christopher | M      | 99    | 52511         |
|  Matthew     | M      | 99    | 44919         |
|  Joshua      | M      | 99    | 43380         |
|  Daniel      | M      | 99    | 33957         |
|--------------+--------+-------+---------------|
{:.table-sql}

}) %>


## Let's remember why we JOIN together


OK, let's take a step back and look at that incredibly intimidating query. And then build it step-by-step, going from the simplest, functional query to the built-up query that we ended up with above.

If you're confused/panicking, now is the time to follow along and type out the queries and execute them. Having to type them out can be a _huge_ aid in slowing your mind down enough to process the code.

_Type_ it out. Don't copy and paste. 


#### Start with SELECT



<%= content_row_side_by_side(%Q{

Remember that, as with 90% of all of our SQL queries, it all begins with a `SELECT` type of statement, specifying a couple of columns `FROM` a table -- in this case, `boynames`.
  
},%Q{
~~~sql
SELECT boynames.name, 
  boynames.babies
FROM boynames;
~~~
  
}) %>






#### Inner JOIN with `girlnames`



<%= content_row_side_by_side(%Q{
We then took that perfectly-fine-if-simple SELECT query and joined it to the table `girlnames`. We also specified that they share a common column, `name`, and this is the condition for the JOIN to be made.
  
},%Q{

~~~sql
SELECT boynames.name, 
  boynames.babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name;
~~~
  
}) %>


Note that I don't bother to include any extra columns yet because it's not necessary. Just look at how many rows the joined query returns: __2,039__ names, i.e. 2,039 different names that were given to boy and girl babies.



#### Filtering for just mostly-male names



<%= content_row_side_by_side(%Q{

Then we wanted to _filter_ the joined result, because we don't want all common names between boys and girls. We want only the names in which there were _more boy babies than girl babies_. This is accomplished in the `WHERE` clause -- this filters the previous result of 2,039 names to just __1,029__ names. 
  
},%Q{
  
~~~sql
SELECT boynames.name, 
  boynames.babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;  
~~~


}) %>


(By the act of simple arithmetic, we can surmise that there are __1,010__ names that are mostly/50%-female).



#### Adding the calculated columns



<%= content_row_side_by_side(%Q{

It's important to know how big the ratio of boy babies to girl babies is for any given name. And, how many total babies were given that name.

These calculations are included as columns and aliased -- for easier readability -- as the target column names in the `gendered_names` table.

  
},%Q{


~~~sql
SELECT 
  boynames.name,   
  (100 * boynames.babies) / 
      (boynames.babies + girlnames.babies) AS ratio,
  boynames.babies + girlnames.babies AS total_babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;  
~~~
  
}) %>






### Setting gender manually

One more thing is missing: the `gender` column. How we set this may be the most confusing part of this query. But [we learned early on that we could](/tutorials/sql-basics/select-and-from/) `SELECT` arbitrary values and have them be a part of the result set, e.g.:

<%= content_row_side_by_side(%Q{

~~~sql
SELECT 
  boynames.name,
  'hello world',
  'whatever' AS gender,
  42 AS "ANSWER TO LIFE",
  '?' AS "༼◕_◕༽"
FROM boynames
LIMIT 5;
~~~
  
},%Q{

|--------------+---------------+----------+----------------+--------|
|  name        | 'hello world' | gender   | ANSWER TO LIFE | ༼◕_◕༽  |
|--------------+---------------+----------+----------------+--------|
|  Michael     | hello world   | whatever | 42             | ?      |
|  Christopher | hello world   | whatever | 42             | ?      |
|  Matthew     | hello world   | whatever | 42             | ?      |
|  Joshua      | hello world   | whatever | 42             | ?      |
|  Daniel      | hello world   | whatever | 42             | ?      |
|--------------+---------------+----------+----------------+--------|
{:.table-sql}

  
}) %>


Why do we even need to set a `gender` value in our results set?


Remember that `boynames` and `girlnames` eschewed having a `gender` or `sex` column simply because, well, the gender is implied in each table name. However, this puts us in a bind, because `gendered_names` expects a `gender` value for each row.

So we simply supply it by setting it _literally_, i.e. as a constant. We know that all names in this query are -- by our definition -- "mostly-male".

~~~sql
SELECT 
  boynames.name,
  'M' AS gender,   
  (100 * boynames.babies) / 
      (boynames.babies + girlnames.babies) AS ratio,
  boynames.babies + girlnames.babies AS total_babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;  
~~~




And that's the complete query for filling `gendered_names` with "mostly-male" names, via `INSERT INTO`, which you can execute on your own.

What about the "mostly-female" names? See if you can tweak the query above to get the desired list of names. I'll show my answer later in this lesson. 

But first, a more important problem...


# What about the all-boy/all-girl names?

We learned in the previous tutorial that 











<%= content_row_side_by_side(%Q{
  
},%Q{
  
}) %>

<%= content_row_side_by_side(%Q{
  
},%Q{
  
}) %>

<%= content_row_side_by_side(%Q{
  
},%Q{
  
}) %>
