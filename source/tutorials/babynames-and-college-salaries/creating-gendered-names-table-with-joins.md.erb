---
title: Creating a Lookup Table for Guessing Gender of Names
description: |
  Using the previous lessons to create a nice convenient table...
listed: true
ranking: 1444
previous: /tutorials/babynames-and-college-salaries/analyzing-androgynous-boy-girl-names-with-joins/  
next: /tutorials/babynames-and-college-salaries/florida-university-employees-and-gender/
---


# Why we need the `gendered_names` table

Using the `babynames` table that we started out with, this is how I would use it to find out if __"Dakota"__ was more likely to belong to a boy or a girl (at least when the 1990 data came out):

<%= content_row_side_by_side(%Q{

~~~sql
SELECT * 
FROM babynames
WHERE name = 'Dakota'
ORDER BY babies DESC;
~~~
}), %Q{

|---------+-----+---------|
|  name   | sex | babies  |
|---------+-----+---------|
|  Dakota | M   | 1549    |
|  Dakota | F   | 380     |
|---------+-----+---------|
{:.table-sql}
  
}) %>


We can eyeball these results and do the math: `100 * 1549 / (1549 + 380)` results in an answer of roughly `80%`, i.e. 80 percent of babies named Dakota are __male__, at least in 1990. So if I were told that the next person I have to talk to is named "Dakota", I'm going to assume it's a male. I might be wrong, but it's the best guess I can make with this data.

But what if I have to look up hundreds of names and determine which are probably male and which are probably female? That simple SQL query is going to get rough...

TKTK




Basically, I want `gendered_names` to be structured such that I can query for any single name and it returns:

1. The `gender` the name is most associated with, e.g. `M` or `F`
2. The `ratio` of babies, with the given `gender`, who were given that name.
3. The `total_babies` given that name. Because for very rare names, the statistical significance of `ratio` may not be very important.

And obviously, the `gendered_names` table would have to have a `name` column to query against. To keep things simple and consistent with the `florida_positions` table (remember that table), we'll also uppercase the names.

Here's a sample query and result:

~~~sql
SELECT * 
FROM gendered_names
WHERE name = 'DAKOTA';
~~~


# Creating the `gendered_names` table

You know how to create a table in SQL by now, try to think what the statement looks like before checking what I think it should be:

~~~sql
CREATE TABLE "gendered_names"(
  "name" VARCHAR,
  "gender" CHAR,
  "ratio" INTEGER,
  "total_babies" INTEGER
);
~~~

(Again, specifying `VARCHAR` and `CHAR` are totally optional for SQLite...you could just as well use `TEXT` -- I do it out of habit from using MySQL for so long...)

# Filling the `gendered_names` table

Obviously, we're going to re-use that `INSERT INTO` statement that we [learned in the last lesson](/tutorials/babynames-and-college-salaries/analyzing-androgynous-boy-girl-names-with-joins/) -- there's no point in further explaining it...it just works, when it comes to transferring data between exiting SQLite tables.

But from what `SELECT` statements do we use? In my mind, it's simplest to not do _one_ statement, but __four__ separate `INSERT INTO` and `SELECT` queries to fill out the `gendered_names` table:

1. Do a `LEFT JOIN`  _from_ `girlnames` to get girl-only names
2. Do a `LEFT JOIN` _from_ `boynames` to get boy-only names
3. Do a `INNER JOIN`  with `boynames` and `girlnames`, then filter for names in which there were equal or _more girl_ than boy babies.
4. Do a `INNER JOIN`  with `boynames` and `girlnames`, then filter for names in which there were _more boy_ than girl babies.

Let's go through each of these queries.


## Selecting girl-only names

We did this in the [previous lesson](/tutorials/babynames-and-college-salaries/analyzing-androgynous-boy-girl-names-with-joins/). See if you can recall it without looking at the previous example.

Here's a hint: we need to start with selecting FROM the `girlnames` table.

And here's the query:

<%= content_row_side_by_side(%Q{

~~~sql
SELECT 
  girlnames.name,
  girlnames.babies
FROM girlnames
LEFT JOIN boynames
  ON boynames.name = girlnames.name
WHERE boynames.name IS NULL;   
~~~
}, %Q{

|-----------------+---------|
|  name           | babies  |
|-----------------+---------|
|  Breanna        | 2952    |
|  Katrina        | 2479    |
|  Alisha         | 2343    |
|  Grace          | 2186    |
|  Krista         | 2143    |
{:.table-sql}
}) %>

### How do we INSERT this thing?







#mark-boygirls-total-babies





### Filtering male- and female- dominated names 

How to divide the set of baby names between mostly-male and mostly-female? Easy, just use a `WHERE` clause: where `boy_babies` > `girl_babies`, it's a "mostly-male" name. And vice versa, for names where `girl_babies` is greater than or equal to `boy_babies`, designated it as "mostly-female" -- Let whomever is querying `gendered_names` decide what to do with names where the `ratio` is near 50.

So to fill `gendered_names`, we'll be executing two very similar-but-not-quite-identical queries. First, the boys; here's what the output of the query looks like before we `INSERT INTO` the `gendered_names` table.

First, the boys...but before we do the `INSERT INTO`, let's preview what this query does:


<%= content_row_side_by_side(%Q{
  

~~~sql
SELECT boynames.name,
  'M' AS gender,
  (100 * boynames.babies) /  (boynames.babies + girlnames.babies) AS ratio,
  boynames.babies + girlnames.babies AS total_babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;
~~~

},%Q{
  

|--------------+--------+-------+---------------|
|  name        | gender | ratio | total_babies  |
|--------------+--------+-------+---------------|
|  Michael     | M      | 99    | 65551         |
|  Christopher | M      | 99    | 52511         |
|  Matthew     | M      | 99    | 44919         |
|  Joshua      | M      | 99    | 43380         |
|  Daniel      | M      | 99    | 33957         |
|--------------+--------+-------+---------------|
{:.table-sql}

}) %>


## Let's remember why we JOIN together


OK, let's take a step back and look at that incredibly intimidating query. And then build it step-by-step, going from the simplest, functional query to the built-up query that we ended up with above.

If you're confused/panicking, now is the time to follow along and type out the queries and execute them. Having to type them out can be a _huge_ aid in slowing your mind down enough to process the code.

_Type_ it out. Don't copy and paste. 


#### Start with SELECT



<%= content_row_side_by_side(%Q{

Remember that, as with 90% of all of our SQL queries, it all begins with a `SELECT` type of statement, specifying a couple of columns `FROM` a table -- in this case, `boynames`.
  
},%Q{
~~~sql
SELECT boynames.name, 
  boynames.babies
FROM boynames;
~~~
  
}) %>






#### Inner JOIN with `girlnames`



<%= content_row_side_by_side(%Q{
We then took that perfectly-fine-if-simple SELECT query and joined it to the table `girlnames`. We also specified that they share a common column, `name`, and this is the condition for the JOIN to be made.
  
},%Q{

~~~sql
SELECT boynames.name, 
  boynames.babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name;
~~~
  
}) %>


Note that I don't bother to include any extra columns yet because it's not necessary. Just look at how many rows the joined query returns: __2,039__ names, i.e. 2,039 different names that were given to boy and girl babies.



#### Filtering for just mostly-male names



<%= content_row_side_by_side(%Q{

Then we wanted to _filter_ the joined result, because we don't want all common names between boys and girls. We want only the names in which there were _more boy babies than girl babies_. This is accomplished in the `WHERE` clause -- this filters the previous result of 2,039 names to just __1,029__ names. 
  
},%Q{
  
~~~sql
SELECT boynames.name, 
  boynames.babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;  
~~~


}) %>


(By the act of simple arithmetic, we can surmise that there are __1,010__ names that are mostly/50%-female).



#### Adding the calculated columns



<%= content_row_side_by_side(%Q{

It's important to know how big the ratio of boy babies to girl babies is for any given name. And, how many total babies were given that name.

These calculations are included as columns and aliased -- for easier readability -- as the target column names in the `gendered_names` table.

  
},%Q{


~~~sql
SELECT 
  boynames.name,   
  (100 * boynames.babies) / 
      (boynames.babies + girlnames.babies) AS ratio,
  boynames.babies + girlnames.babies AS total_babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;  
~~~
  
}) %>






### Setting gender manually

One more thing is missing: the `gender` column. How we set this may be the most confusing part of this query. But [we learned early on that we could](/tutorials/sql-basics/select-and-from/) `SELECT` arbitrary values and have them be a part of the result set, e.g.:

<%= content_row_side_by_side(%Q{

~~~sql
SELECT 
  boynames.name,
  'hello world',
  'whatever' AS gender,
  42 AS "ANSWER TO LIFE",
  '?' AS "༼◕_◕༽"
FROM boynames
LIMIT 5;
~~~
  
},%Q{

|--------------+---------------+----------+----------------+--------|
|  name        | 'hello world' | gender   | ANSWER TO LIFE | ༼◕_◕༽  |
|--------------+---------------+----------+----------------+--------|
|  Michael     | hello world   | whatever | 42             | ?      |
|  Christopher | hello world   | whatever | 42             | ?      |
|  Matthew     | hello world   | whatever | 42             | ?      |
|  Joshua      | hello world   | whatever | 42             | ?      |
|  Daniel      | hello world   | whatever | 42             | ?      |
|--------------+---------------+----------+----------------+--------|
{:.table-sql}

  
}) %>


Why do we even need to set a `gender` value in our results set?


Remember that `boynames` and `girlnames` eschewed having a `gender` or `sex` column simply because, well, the gender is implied in each table name. However, this puts us in a bind, because `gendered_names` expects a `gender` value for each row.

So we simply supply it by setting it _literally_, i.e. as a constant. We know that all names in this query are -- by our definition -- "mostly-male".

~~~sql
SELECT 
  boynames.name,
  'M' AS gender,   
  (100 * boynames.babies) / 
      (boynames.babies + girlnames.babies) AS ratio,
  boynames.babies + girlnames.babies AS total_babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;  
~~~




And that's the complete query for filling `gendered_names` with "mostly-male" names, via `INSERT INTO`, which you can execute on your own.

What about the "mostly-female" names? See if you can tweak the query above to get the desired list of names. I'll show my answer later in this lesson. 

But first, a more important problem...


# What about the all-boy/all-girl names?

We [learned in the previous tutorial](/tutorials/babynames-and-college-salaries/inner-left-joins-few-babynames/) that INNER JOINs let us find common names between tables.  

But what about all the names _not_ common between `boynames` and `girlnames`?

That's what __LEFT JOINS__ are for. 

## Count up boy- and girl-only names with LEFT JOINS

As a refresher, let's count the number of names exclusive to `boynames` and `girlnames`:




## Insert the gender-exclusive names into `gendered_names`

Now we need to insert the boy- and girl-only names into `gendered_names`. This is actually easier than doing the shared-names.

Let's insert the __girl-only__ names first.


#### SELECT the names and numbers FROM the `girlnames` table

First, we start off with the basic `SELECT` statement to pull names and numbers from `girlnames`:

~~~sql
SELECT 
  girlnames.name,
  girlnames.babies
FROM girlnames;
~~~

#### LEFT JOIN the `boynames` table

This JOIN syntax should seem familiar by now.

~~~sql
SELECT 
  girlnames.name,
  girlnames.babies
FROM girlnames
LEFT JOIN boynames
  ON girlnames.name = boynames.name;
~~~

#### Use `WHERE` to filter for girl names that weren't in `boynames`

And here's the kicker; all `name` values from `girlnames` that _don't_ have a match in `boynames` will be listed in the results but won't have a corresponding `boynames.name` match.

So using `WHERE` to select rows in which `boynames.name IS NULL` is how we get the girl-only names:

~~~sql
SELECT 
  girlnames.name,
  girlnames.babies
FROM girlnames
LEFT JOIN boynames
  ON girlnames.name = boynames.name
WHERE boynames.name IS NULL;
~~~

#### Add the already-obvious calculated/derived columns

Now it's just a matter of arranging the `SELECT` clause to include the expected columns for the `gendered_names` table. 

But since we know that all of these names are __girl-only__, that means that we can set `ratio` to `100`. In other words, 100% of babies named 'Katrina' are girls. That also means that `total_babies` is just `girlnames.babies` -- there are no `boynames.babies` to add together!

~~~sql
SELECT 
  girlnames.name,
  'F' AS gender,
  100 AS ratio,
  girlnames.babies AS total_babies
FROM girlnames
LEFT JOIN boynames
  ON girlnames.name = boynames.name
WHERE boynames.name IS NULL;
~~~

As before, in the `INNER JOIN` example, see if you can rewrite the above query to include the `boynames` data.



# All together

This has been a long walkthrough, so let's review what we need to do:

- Create a new table named `gendered_names` with columns for `name`, `gender`, `ratio`, and `total_babies`













<%= content_row_side_by_side(%Q{
  
},%Q{
  
}) %>

<%= content_row_side_by_side(%Q{
  
},%Q{
  
}) %>



TTKTK alltogther


~~~sql
DROP TABLE IF EXISTS "gendered_names";
CREATE TABLE "gendered_names"(
  "name" VARCHAR,
  "gender" CHAR,
  "ratio" INTEGER,
  "total_babies" INTEGER
);

INSERT INTO "gendered_names"
SELECT 
  girlnames.name,
  'F' AS gender,
  100 AS ratio,
  girlnames.babies AS total_babies
FROM girlnames
LEFT JOIN boynames
  ON boynames.name = girlnames.name
WHERE boynames.name IS NULL; 

INSERT INTO "gendered_names"
SELECT 
  boynames.name,
  'M' AS gender,
  100 AS ratio,
  boynames.babies AS total_babies
FROM boynames
LEFT JOIN girlnames
  ON boynames.name = girlnames.name
WHERE girlnames.name IS NULL; 


INSERT INTO "gendered_names"
SELECT 
  boynames.name,   
  'F' AS gender,
  (100 * boynames.babies) / 
      (boynames.babies + girlnames.babies) AS ratio,
  boynames.babies + girlnames.babies AS total_babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE boynames.babies > girlnames.babies;  

INSERT INTO "gendered_names"
SELECT 
  girlnames.name,
  'F' AS gender,   
  (100 * girlnames.babies) / 
      (boynames.babies + girlnames.babies) AS ratio,
  boynames.babies + girlnames.babies AS total_babies
FROM boynames
INNER JOIN girlnames
  ON boynames.name = girlnames.name
WHERE girlnames.babies >= boynames.babies ;  


UPDATE gendered_names
SET name = UPPER(name);


~~~
