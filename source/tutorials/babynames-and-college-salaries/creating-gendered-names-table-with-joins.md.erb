---
title: Creating a Lookup Table for Guessing Gender of Names
description: |
  Using the previous lessons to create a nice convenient table...
listed: true
ranking: 1444
previous: /tutorials/babynames-and-college-salaries/analyzing-androgynous-boy-girl-names-with-joins/
next: /tutorials/babynames-and-college-salaries/florida-university-employees-and-gender/
---

I wrapped up the last lesson by mentioning it'd be nice to have a table -- which I'll just name `gendered_names` -- to make it easier to calculate the likelihood that a given name belongs to a boy or a girl. In this lesson, we build it, one SQL query at a time.

<%= render_toc %>

# Why we need to build the `gendered_names` table

Using the `babynames` table that we started out with, this is how I would use it to find out if __"Dakota"__ was more likely to belong to a boy or a girl (at least when the 1990 data came out):

<%= content_row_side_by_side(%Q{
~~~sql
SELECT * 
FROM babynames
WHERE name = 'Dakota'
ORDER BY babies DESC;
~~~
}, %Q{
|---------+-----+---------|
|  name   | sex | babies  |
|---------+-----+---------|
|  Dakota | M   | 1549    |
|  Dakota | F   | 380     |
|---------+-----+---------|
{:.table-sql}
}) %>

We can eyeball these results and do the math: `100 * 1549 / (1549 + 380)` results in an answer of roughly `80%`, i.e. 80 percent of babies named Dakota are __male__, at least in 1990. 

OK, seems easy enough. But what if I have to look up hundreds of names and determine which are probably male and which are probably female? That simple SQL query and mental math is going to get rough. Certainly, it's not going to scale across tens of thousands of names.

Instead, we want a table as easy to use as this:


<%= content_row_side_by_side(%Q{
~~~sql
SELECT * 
FROM gendered_names
WHERE name = 'Dakota';
~~~
}, %Q{
|---------+--------+-------+---------------|
|  name   | gender | ratio | total_babies  |
|---------+--------+-------+---------------|
|  Dakota | M      | 80    | 1929          |
|---------+--------+-------+---------------|
{:.table-sql}
}) %>

If you can't see how this can easily be joined against any other kind of table, that's fine...but at least you can see how `gendered_names` returns an easy-to-digest single row.

A few things to note:

1. The `gender` the name indicates the _most likely_ gender, e.g. `M` or `F`
2. Just _how_ likely? If a user really wants to know, `gendered_names` has a `ratio` column, which represents what percentage of babies belong to the corresponding most-likely `gender`.
3. But for very rare names, the fact that all 5 of them were boy or girls is not very comforting. OK, so the `total_babies` column is there for the user to figure out the statistical significance any way they like.

And to keep things simple and consistent with the `florida_positions` table -- remember _that_ table? We're about to return to it -- we should also uppercase the names.

Sound good? Let's build it out of pure SQL and (simple) math.


# Creating the `gendered_names` table

You know how to create a table in SQL by now, so try to think what the statement looks like before seeing the scheme that I propose below: 

~~~sql
CREATE TABLE "gendered_names"(
  "name" VARCHAR,
  "gender" CHAR,
  "ratio" INTEGER,
  "total_babies" INTEGER
);
~~~

(Again, specifying `VARCHAR` and `CHAR` are totally optional for SQLite...you could just as well use `TEXT` -- I do it out of habit from using MySQL for so long...)

# Filling the `gendered_names` table

Obviously, we're going to re-use that `INSERT INTO` statement that we [learned in the last lesson](/tutorials/babynames-and-college-salaries/analyzing-androgynous-boy-girl-names-with-joins/) -- there's no point in further explaining it...it just works, when it comes to transferring data between exiting SQLite tables.

But from what `SELECT` statements do we use? In my mind, it's simplest to not do _one_ statement, but __four__ separate `INSERT INTO` and `SELECT` queries to fill out the `gendered_names` table:

1. Do a `LEFT JOIN`  _from_ `girlnames` to get girl-only names
2. Do a `LEFT JOIN` _from_ `boynames` to get boy-only names
3. Do a `INNER JOIN`  with `boynames` and `girlnames`, then filter for names in which there were equal or _more girl_ than boy babies.
4. Do a `INNER JOIN`  with `boynames` and `girlnames`, then filter for names in which there were _more boy_ than girl babies.

Let's go through each of these queries.


## Selecting girl-only names

We did this in the [previous lesson](/tutorials/babynames-and-college-salaries/analyzing-androgynous-boy-girl-names-with-joins/). See if you can recall it without looking at the previous example.

Here's a hint: we need to start with selecting FROM the `girlnames` table.

And here's the query:

<%= content_row_side_by_side(%Q{

~~~sql
SELECT 
  girlnames.name,
  girlnames.babies
FROM girlnames
LEFT JOIN boynames
  ON boynames.name = girlnames.name
WHERE boynames.name IS NULL;   
~~~
}, %Q{

|-----------------+---------|
|  name           | babies  |
|-----------------+---------|
|  Breanna        | 2952    |
|  Katrina        | 2479    |
|  Alisha         | 2343    |
|  Grace          | 2186    |
|  Krista         | 2143    |
{:.table-sql}
}) %>


### How do we INSERT this thing?

Remember that the schema for `gendered_names` contains four columns:

      "name" VARCHAR,
      "gender" CHAR,
      "ratio" INTEGER,
      "total_babies" INTEGER

These columns are easy to calculate because of the nature of our `LEFT JOIN`, in which we know that all of the names returned are exclusively female:

This means that `gender` can just be set to `'F'`. If you remember back [to an early lesson about SQL](/tutorials/sql-basics/select-and-from/), we can arbitrarily include constant and literal values in a query results:

<%= content_row_side_by_side(%Q{
~~~sql
SELECT 
  boynames.name,
  'hello world',
  'whatever' AS gender,
  42 AS "ANSWER TO LIFE",
  '?' AS "༼◕_◕༽"
FROM boynames
LIMIT 3;
~~~
},%Q{
|--------------+---------------+----------+----------------+--------|
|  name        | 'hello world' | gender   | ANSWER TO LIFE | ༼◕_◕༽  |
|--------------+---------------+----------+----------------+--------|
|  Michael     | hello world   | whatever | 42             | ?      |
|  Christopher | hello world   | whatever | 42             | ?      |
|  Matthew     | hello world   | whatever | 42             | ?      |
{:.table-sql}
})%>

In terms of `ratio`, if we know these names were given only to females, then the female ratio of that name is 100%.

And of course, this means that `total_babies` is just equal to `girlnames.babies`, as there are no boy babies with these names.

Here's the query, basically unchanged except for the additional, aliased columns:

<%= content_row_side_by_side(%Q{
~~~sql
SELECT 
  girlnames.name AS name,
  'F' AS gender,
  100 AS ratio,
  girlnames.babies AS total_babies
FROM girlnames
LEFT JOIN boynames
  ON boynames.name = girlnames.name
WHERE boynames.name IS NULL;   
~~~
}, %Q{

|-----------------+--------+-------+---------------|
|  name           | gender | ratio | total_babies  |
|-----------------+--------+-------+---------------|
|  Breanna        | F      | 100   | 2952          |
|  Katrina        | F      | 100   | 2479          |
|  Alisha         | F      | 100   | 2343          |
|  Grace          | F      | 100   | 2186          |
|  Krista         | F      | 100   | 2143          |
{:.table-sql}

}) %>



### Selecting boy-only names

See if you can figure this out on your own. It requires just a few changes to the `LEFT JOIN` we did for girl-only names. 

(If you don't get it, I provide the answer later in this lesson).



## Selecting names in which girl babies equal or outnumber boy babies

Selecting for common values in two different tables requires the `INNER JOIN`.

The syntax is largely the same as the `LEFT JOIN`, except use `INNER` instead of `LEFT`, of course. The following inner-join query returns the names common to both `boynames` and `girlnames`:


<%= content_row_side_by_side(%Q{
~~~sql
SELECT 
  girlnames.name,
  girlnames.babies
FROM girlnames
INNER JOIN boynames
  ON boynames.name = girlnames.name;
~~~
}, %Q{

|--------------+---------|
|  name        | babies  |
|--------------+---------|
|  Jessica     | 46466   |
|  Ashley      | 45549   |
|  Brittany    | 36535   |
|  Amanda      | 34406   |
|  Samantha    | 25864   |
{:.table-sql}
}) %>

### Filtering for names given mostly to girls

I've decided arbitrarily to designate names that were split evenly between boys and girls as "female". So we use the greater-than-or-equal operator in the `WHERE` condition, i.e. `>=`:


~~~sql
SELECT 
  girlnames.name,
  girlnames.babies
FROM girlnames
INNER JOIN boynames
  ON boynames.name = girlnames.name
WHERE girlnames.babies > boynames.babies;
~~~

### Calculating the extra columns for `gendered_names`

Again, the literal value, `'F'`, can be passed into the `gender` column.

The `total_babies` value is the sum of `boynames.babies` and `girlnames.babies`.

As far as `ratio`, this is only slightly more complicated: it's the result of multiplying `100` by `girlnames.babies` and dividing the result by `total_babies`, though we have to explicitly restate that calculation, i.e. we can't refer to `total_babies` and must re-add `boynames.babies` with `girlnames.babies`.

Nothing else about the query changes:

~~~sql
SELECT 
  girlnames.name,
  'F' AS gender,
  100 * girlnames.babies / 
          (girlnames.babies + boynames.babies) AS ratio,
  girlnames.babies + boynames.babies AS total_babies
FROM girlnames
INNER JOIN boynames
  ON boynames.name = girlnames.name
WHERE girlnames.babies >= boynames.babies;
~~~

|-------------+--------+-------+---------------|
|  name       | gender | ratio | total_babies  |
|-------------+--------+-------+---------------|
|  Jessica    | F      | 99    | 46606         |
|  Ashley     | F      | 99    | 45788         |
|  Brittany   | F      | 99    | 36647         |
|  Amanda     | F      | 99    | 34502         |
|  Samantha   | F      | 99    | 25922         |
{:.table-sql}



Now we're ready to add these "mostly-female" names to the `gendered_names` table.


### Filtering for names given mostly to boys


Again, see if you can figure this out on your own, it's very similar to deriving the mostly-female names.  If you don't get it, I provide the answer below



# All together!

OK, let's add the data to `gendered_names`. Since it's so long since we last looked at the table schema, we might as well `DROP` it (if it still exists), re-create it, and then run the queries described above.

### Create the `gendered_names` table

~~~sql
DROP TABLE IF EXISTS "gendered_names";
CREATE TABLE "gendered_names"(
  "name" VARCHAR,
  "gender" CHAR,
  "ratio" INTEGER,
  "total_babies" INTEGER
);
~~~


### Add the boy- and girl-only names

First, the boy-only names:

~~~sql
INSERT INTO "gendered_names"
  SELECT 
    boynames.name AS name,
    'M' AS gender,
    100 AS ratio,
    boynames.babies AS total_babies
  FROM boynames
  LEFT JOIN girlnames
    ON boynames.name = girlnames.name
  WHERE girlnames.name IS NULL;
~~~


Then the girl-only names:

~~~sql
INSERT INTO "gendered_names"
  SELECT 
    girlnames.name AS name,
    'F' AS gender,
    100 AS ratio,
    girlnames.babies AS total_babies
  FROM girlnames
  LEFT JOIN boynames
    ON boynames.name = girlnames.name
  WHERE boynames.name IS NULL;
~~~


### Add the mixed-gender names


First, the mostly-boy names:

~~~sql
INSERT INTO "gendered_names"
  SELECT 
    boynames.name,
    'M' AS gender,
    100 * boynames.babies / 
            (girlnames.babies + boynames.babies) AS ratio,
    girlnames.babies + boynames.babies AS total_babies
  FROM girlnames
  INNER JOIN boynames
    ON boynames.name = girlnames.name
  WHERE boynames.babies > girlnames.babies;
~~~


Then the mostly (or at least 50%)-girl names:

~~~sql
INSERT INTO "gendered_names"
  SELECT 
    girlnames.name,
    'F' AS gender,
    100 * girlnames.babies / 
            (girlnames.babies + boynames.babies) AS ratio,
    girlnames.babies + boynames.babies AS total_babies
  FROM girlnames
  INNER JOIN boynames
    ON boynames.name = girlnames.name
  WHERE girlnames.babies >= boynames.babies;
~~~


## Did it work?

That was a lot of code we just copy-pasted/retyped, which means there is a lot of possibility for human error -- think fatigue or clumsy fingers -- and for the kind of errors that don't get caught by the SQLite interpreter.

The very least we can do is confirm the [counts that we got in the previous lesson](/tutorials/babynames-and-college-salaries/analyzing-androgynous-boy-girl-names-with-joins/)

|                  | name count | total babies |
|------------------|------------|--------------|
| All              | 22,674     | 3,950,252    |
| Boy & girl names | 2,039      | 3,198,292    |
| Boy-only names   | 7,443      | 257,039      |
| Girl-only names  | 13,192     | 494,921      |
{:.table-sql}


Here are the queries to do so; you can run them yourself:

~~~sql
SELECT 
  COUNT(*) AS all_name_count, 
  SUM(total_babies) AS all_total_babies
FROM gendered_names;
~~~


~~~sql
SELECT 
  COUNT(*) AS mixed_sex_name_count, 
  SUM(total_babies) AS mixed_sex_total_babies
FROM gendered_names
WHERE ratio BETWEEN 1 AND 99;
~~~


~~~sql
SELECT 
  COUNT(*) AS boy_only_name_count, 
  SUM(total_babies) AS boy_only_total_babies
FROM gendered_names
WHERE ratio = 100 
  AND gender = 'M';
~~~

~~~sql
SELECT 
  COUNT(*) AS girl_only_name_count, 
  SUM(total_babies) AS girl_only_total_babies
FROM gendered_names
WHERE ratio = 100 
  AND gender = 'F';
~~~


The results of the queries should equal the values in the table above. At least, they did for me...


# Putting the `gendered_names` table to use

Whew, that was a lot of work. Let's try it out!

