---
title: More Boolean Expressions to Filter SQL Queries
description: |
  How to filter SQL data using comparison operators, such as "greater than" and "not equal to". Mostly, this is a review of how tricky logical expressions can be.
listed: true
ranking: 525
previous: /tutorials/sql-basics/where-clause-as-filter
takeaways:
  - |
    The meaning of each of these operators:
    - `!=`
    - `>=` and `>`
    - `<=` and `<`
  - How to use the `NOT` keyword
---


<%= render_toc %>

<% content_card("Get the data") do  %>
For this lesson, download the following file, which is a SQLite database built from the [U.S. Social Security Administration file of popular baby names](http://www.ssa.gov/oact/babynames/limits.html): 

- [`ssa_baby_names--2010_2014--all.sqlite.zip`](http://stash.padjo.org/data/ssa_baby_names--2010_2014--all.sqlite.zip)

Unzip it, and open the `sqlite` file using the SQLite client of your choice (e.g. [DB Browser for SQLite](http://sqlitebrowser.org/))
<% end %>



# Finding non-matches with `!=`

We know how to filter rows by using the __equals__ sign to make exact matches. To filter for non-matches, or rather, __not equals__, put an __exclamation mark__ before the equals sign.

The following query will return all rows in which the name is _not_ `'Daniel'`:

~~~sql
SELECT * 
FROM baby_names
WHERE name != 'Daniel'
~~~

As with the plain equals-sign operator, we can use `!=` in a variety of combinations. Here's a query for rows in which the name is _neither_ `'Daniel'` nor `'John'`, for all years _except_ `2013`:

~~~sql
SELECT * 
FROM baby_names
WHERE name != 'Daniel' 
  AND name != 'John'
  AND year != 2013
~~~

## Beware of using `OR` in an exclusionary condition

Remember that the `OR` keyword, by its very definition, _expands_ the possible set of rows that can pass a condition. For example the following query:

~~~sql
SELECT * FROM baby_names 
  WHERE name = 'Daniel' 
    OR name = 'John'
~~~

Contains all of the rows by these two separate queries:

~~~sql
SELECT * FROM baby_names 
  WHERE name = 'Daniel' 
~~~

~~~sql
SELECT * FROM baby_names 
  WHERE name = 'John' 
~~~

`OR` wants everyone to have fun! But if you are trying to _exclude_ rows, then `OR` becomes a bit too permissive. Let's revisit the previous example that used `!=`

~~~sql
SELECT * 
FROM baby_names
WHERE name != 'Daniel' 
  OR name != 'John'
~~~

Guess what that is equal to?

~~~sql
SELECT * 
FROM baby_names
~~~

By using `OR`, the `WHERE` condition can be described in English as:

      Include all the rows in which the name
      is NOT "Daniel", 
      OR, the name is NOT "John"

Well, a row in which the name is `'John'` is _also_ a row in which the name is __not__ `'Daniel'`. The condition as stated above includes a row if its `name` is not equal to `'Daniel'`. Thus, `'John'` rows are included, even though they fail the other (optional) requirement: `name` is not equal to `'John'`.

But again, `OR` makes the requirements _optional_. Thus, two exclusive filters joined by an `OR` can result in _nothing_ being excluded.


TODO: This probably requires a diagram. Oh well.


Basically, _don't get fancy_ when trying to _not_ include things. It's not unlike the confusion generated by a double negative, if you don't don't get my drift, eh?

# Greater and less than

If you remember elementary school math, this is pretty straightforward.

To fetch all records _before_ (i.e. `year` __less than__) `2012`:

~~~sql
SELECT * 
FROM baby_names
WHERE year < 2012;
~~~

To fetch all records _after_ (i.e. `year` __greater than__) `2012`:


~~~sql
SELECT * 
FROM baby_names
WHERE year > 2012;
~~~


## Greater/less than or equal to 

To include the boundary number in a comparison, append the __equals__ sign after the comparison operator.

To fetch all records _before or during_ (i.e. `year` __less than or equal to__) `2012`:

~~~sql
SELECT * 
FROM baby_names
WHERE year <= 2012;
~~~

To fetch all records _during or after_ (i.e. `year` __greater than or equal to__) `2012`:

~~~sql
SELECT * 
FROM baby_names
WHERE year >= 2012;
~~~



## Combining numerical comparisons to create a range

Using the `AND` operator, you can specify a lower- and upper-bound to a range:

All records _after_ 2011 but _before_ 2014:

~~~sql
SELECT * 
FROM baby_names
WHERE year > 2011 
  AND year < 2014;
~~~

Using `OR`, you can specify values that fall _outside_ a range:

All records that are _before_ 2011 or _after_ 2013:

~~~sql
SELECT * 
FROM baby_names
WHERE year < 2011 
  OR year > 2013;
~~~



## Comparing text characters

Text characters can be compared against each other, i.e. the letter `'M'` is "greater than" the letter `'H'`.

To get the names between the letters `'T'` and `'Y'`, i.e. all the names that begin with either of the letters `'U'`, `'V'`, and `'X'`:

~~~sql
SELECT * 
FROM baby_names
WHERE name >= 'U' 
  AND name < 'Y';
~~~

## More logical pitfalls


But be careful that the combination of conditions doesn't lead to a logical impossibility:

~~~sql
SELECT * 
FROM baby_names
WHERE year > 2011 
  AND year < 2013;
~~~


~~~sql
SELECT * 
FROM baby_names
WHERE name < 'G' 
  AND name > 'Z';
~~~


# The `NOT` keyword

The `NOT` keyword can be used to _modify_ another keyword, such as `AND` or `OR`.

The following query looks for records in which the `year` is `2013` but the `sex` is _not_ equal to `'F'`:

~~~sql
SELECT * 
FROM baby_names
WHERE year = 2013 
  AND NOT sex = 'F'
~~~

This is equivalent to this use of plain `AND` and the `!=` operator:

~~~sql
SELECT * 
FROM baby_names
WHERE year = 2013 
  AND sex != 'F'
~~~


Again, the `NOT` keyword is just another way to express yourself logically, but don't use it if it doesn't make sense in plain English.
